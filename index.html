<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Interview Tutor — AI Developer Practice & Score</title>
<link rel="icon" href="data:;base64,iVBORw0KGgo=">
<link rel="stylesheet" href="/css/styles.css">
</head>
<body>
  <div class="top-header">
    <img src="/images/logo.png" alt="Interview Tutor Logo" class="top-header-logo" />
    <span class="top-header-title">Adam's AI Career Coach</span>
  </div>
  <div class="wrap">
    <div class="panel">
      <header>
        <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;width:100%;">
          <h1 style="margin:0;color:var(--accent);text-align:center;">Interview Tutor <span style="color:var(--muted);font-weight:600;">- AI Developer</span></h1>
          <p style="margin:2px 0 0;color:var(--muted);text-align:center;">Practice, get graded, and level up your AI developer interview skills.</p>
        </div>
        <div style="flex:1"></div>
      </header>
      <div class="controls">
        <div class="controls-row" style="flex:1;flex-direction:row;gap:10px;align-items:center;justify-content:flex-start;">
          <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
            <input id="coachInput" type="text" placeholder="Enter career coach (e.g. AI Developer, Product Manager)" style="min-width:220px" />
            <button id="coachSubmitBtn" class="primary">Find Areas</button>
            <select id="areaSelect" title="Choose topic area" disabled>
              <option value="">Select area to practice</option>
            </select>
            <select id="difficultySelect" title="Select difficulty">
              <option value="medium">Medium</option>
              <option value="easy">Easy</option>
              <option value="hard">Hard</option>
            </select>
          </div>
          <button id="startBtn" class="primary" style="margin-left:18px;min-width:160px;" disabled>Start Question</button>
        </div>
      </div>
      <div id="mainArea" class="question-card">
        <div class="q-head">
          <div>
            <div class="q-area-title" id="currentAreaLabel">Pick an area and press Start</div>
            <div class="tiny" id="qmeta">No question yet.</div>
          </div>
          <div class="meta">
            <div id="qDifficulty" class="tiny muted"></div>
            <div id="qTimer" class="tiny muted"></div>
          </div>
        </div>
        <div id="questionBox" class="q-box" aria-live="polite">Questions generated by the AI will appear here.</div>
        <div>
          <textarea id="answerInput" class="answer" placeholder="Type your answer here..."></textarea>
          <div class="hint">Tip: write as if explaining to an interviewer. Keep code concise and explain time/space complexity when relevant.</div>
        </div>
        <div style="display:flex;gap:10px;margin-top:10px;flex-wrap:wrap">
          <button id="submitBtn" class="primary">Submit Answer</button>
          <button id="hintBtn" class="ghost">Ask for Hint</button>
          <button id="explainBtn" class="ghost">Ask for Model Explanation</button>
          <div style="flex:1"></div>
          <div id="statusMsg" class="tiny muted center"></div>
        </div>
        <div id="feedbackPane" style="margin-top:12px;display:none">
          <div class="section-title" style="color:var(--accent-2);font-weight:700;margin-bottom:6px">
            AI Feedback & Grade: <span id="feedbackGrade" style="color:var(--accent);font-weight:800"></span>
          </div>
          <div id="feedbackBox" class="q-box" style="min-height:80px"></div>
          <div id="improvedAnswerBox" class="q-box" style="min-height:40px;margin-top:8px;display:none"></div>
        </div>
        <div id="hintPane" style="margin-top:12px;display:none">
          <div class="section-title" style="color:var(--accent-2);font-weight:700;margin-bottom:6px">
            Hint
          </div>
          <div id="hintBox" class="q-box" style="min-height:40px"></div>
        </div>
        <div id="explanationPane" style="margin-top:12px;display:none">
          <div class="section-title" style="color:var(--accent-2);font-weight:700;margin-bottom:6px">
            Model Explanation
          </div>
          <div id="explanationBox" class="q-box" style="min-height:40px"></div>
        </div>
      </div>
      <footer>
      </footer>
    </div>
    <aside class="panel">
      <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;">
        <div class="small muted" style="text-align:center;">Overall Score</div>
        <div class="big-score" id="globalScore" style="text-align:center;">—</div>
        <div style="margin-top:18px;text-align:center;">
          <div class="small muted">Current Area</div>
          <div id="sidebarArea" style="font-weight:800;color:var(--accent);margin-top:6px;text-align:center;">—</div>
        </div>
      </div>
      <div style="margin-top:12px" class="scorecard">
        <div class="stat"><div class="k">Area Average</div><div class="v" id="areaAvg">—</div></div>
        <div class="stat"><div class="k">Attempts</div><div class="v" id="areaAttempts">0</div></div>
        <div class="stat"><div class="k">Last Grade</div><div class="v" id="lastGrade">—</div></div>
      </div>
      <div style="margin-top:14px">
        <div class="small muted" style="margin-bottom:8px">Recent Activity</div>
        <div class="history" id="history"></div>
      </div>
      <div style="margin-top:14px;display:flex;gap:8px">
        <button id="resetAreaBtn" class="ghost">Reset Area Scores</button>
        <button id="resetAllBtn" class="ghost">Reset All</button>
      </div>
      <div style="margin-top:12px" class="tiny muted">
        Data persisted locally in your browser (localStorage). You can clear via Reset All.
      </div>
      <div class="tiny muted" style="margin-top:4px">
        Scores of 90%+ are considered excellent. 100% is rarely awarded due to strict grading.
      </div>
      <div id="areaScoresSummary" style="margin-top:18px">
      </div>
    </aside>
  </div>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-xxxxxxxxxxxxxxxx"
     data-ad-slot="1234567890"
     data-ad-format="auto"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
<script>
function getCsrfToken(){
  const token = document.cookie.split('; ').find(row => row.startsWith('csrf-token='));
  return token ? decodeURIComponent(token.split('=')[1]) : '';
}
let csrfTokenCache = getCsrfToken();
async function ensureCsrfToken(){
  csrfTokenCache = csrfTokenCache || getCsrfToken();
  if (csrfTokenCache) return csrfTokenCache;
  const resp = await fetch('/api/csrf', { credentials: 'same-origin' });
  if (!resp.ok) throw new Error('Unable to obtain CSRF token');
  const data = await resp.json();
  csrfTokenCache = data.token;
  return csrfTokenCache;
}
async function csrfFetch(url, options = {}){
  const token = await ensureCsrfToken();
  const headers = Object.assign({}, options.headers, { 'X-CSRF-Token': token });
  return fetch(url, { ...options, headers, credentials: 'same-origin' });
}
+ensureCsrfToken().catch(console.error);
 let currentCoach = localStorage.getItem('interviewTutorLastCoach') || 'AI Developer'; // Default fallback

const coachInput = document.getElementById('coachInput');
const coachSubmitBtn = document.getElementById('coachSubmitBtn');
const areaSelect = document.getElementById('areaSelect');
const difficultySelect = document.getElementById('difficultySelect');
const startBtn = document.getElementById('startBtn');
const submitBtn = document.getElementById('submitBtn');
const hintBtn = document.getElementById('hintBtn');
const explainBtn = document.getElementById('explainBtn');
const questionBox = document.getElementById('questionBox');
const answerInput = document.getElementById('answerInput');
const feedbackPane = document.getElementById('feedbackPane');
const feedbackBox = document.getElementById('feedbackBox');
const feedbackGrade = document.getElementById('feedbackGrade');
const improvedAnswerBox = document.getElementById('improvedAnswerBox');
const hintPane = document.getElementById('hintPane');
const hintBox = document.getElementById('hintBox');
const explanationPane = document.getElementById('explanationPane');
const explanationBox = document.getElementById('explanationBox');
const currentAreaLabel = document.getElementById('currentAreaLabel');
const qmeta = document.getElementById('qmeta');
const qDifficulty = document.getElementById('qDifficulty');
const qTimer = document.getElementById('qTimer');
const statusMsg = document.getElementById('statusMsg');
const sidebarArea = document.getElementById('sidebarArea');
const globalScore = document.getElementById('globalScore');
const areaAvg = document.getElementById('areaAvg');
const areaAttempts = document.getElementById('areaAttempts');
const lastGrade = document.getElementById('lastGrade');
const historyEl = document.getElementById('history');
let currentQuestion = null;
let questionStartTime = null;
let timerInterval = null;
let scores = loadScores(); 
let streak = 0;
let lastSubmittedAnswer = '';

function saveScores(){ localStorage.setItem('interviewTutorScores', JSON.stringify(scores || {})); }
function loadScores(){ try{ return JSON.parse(localStorage.getItem('interviewTutorScores') || '{}') }catch(e){ return {}; } }
function nowISO(){ return new Date().toISOString(); }

function startTimer(){ questionStartTime = Date.now(); qTimer.textContent = 'Time: 00:00'; clearInterval(timerInterval); timerInterval = setInterval(()=>{
  const diff = Math.floor((Date.now()-questionStartTime)/1000);
  const mm = String(Math.floor(diff/60)).padStart(2,'0');
  const ss = String(diff%60).padStart(2,'0');
  qTimer.textContent = `Time: ${mm}:${ss}`;
}, 1000); }
function stopTimer(){ clearInterval(timerInterval); timerInterval = null; }

function renderSidebar(area){
  sidebarArea.textContent = area || '—';
  const global = computeGlobalScore();
  globalScore.textContent = global === null ? '—' : `${Math.round(global)}%`;
  if(!area) {
    areaAvg.textContent = '—'; areaAttempts.textContent='0'; lastGrade.textContent='—';
    historyEl.innerHTML='';
    renderAreaScoresSummary();
    return;
  }
  const a = scores[area];
  if(!a){
    areaAvg.textContent='—'; areaAttempts.textContent='0'; lastGrade.textContent='—'; historyEl.innerHTML='';
    renderAreaScoresSummary();
    return;
  }
  areaAvg.textContent = `${Math.round(a.avg)}%`;
  areaAttempts.textContent = `${a.attempts || 0}`;
  lastGrade.textContent = a.last !== undefined ? `${Math.round(a.last)}%` : '—';
  const hist = (a.history||[]).slice().reverse();
  historyEl.innerHTML = hist.map(h=>`
    <div class="item" title="${h.time}">
      <div class="h-title">${h.questionTitle || 'Question'}</div>
      <div class="tiny muted">${h.time.replace('T',' ').split('.')[0]}</div>
      <div style="margin-top:6px">${h.resultText || ''}</div>
    </div>
  `).join('');
  renderAreaScoresSummary();
}

function computeGlobalScore(){
  const keys = Object.keys(scores);
  if(keys.length===0) return null;
  let total=0, attempts=0;
  keys.forEach(k=>{
    const a = scores[k];
    if(a && a.attempts) { total += (a.avg * a.attempts); attempts += a.attempts; }
  });
  if(attempts===0) return null;
  return total/attempts;
}

function loadQuestionHistory() {
  try {
    return JSON.parse(localStorage.getItem('interviewTutorLastQuestions') || '[]');
  } catch (e) {
    return [];
  }
}
function saveQuestionHistory(history) {
  localStorage.setItem('interviewTutorLastQuestions', JSON.stringify(history.slice(-10)));
}
function addQuestionToHistory(question) {
  let history = loadQuestionHistory();
  history.push(question);
  saveQuestionHistory(history);
}
function clearQuestionHistory() {
  localStorage.removeItem('interviewTutorLastQuestions');
}

function buildQuestionPrompt(area, difficulty){
  const lastQuestions = loadQuestionHistory();
  const sys = `You are an expert technical interviewer and grading assistant for ${currentCoach} roles.
Produce a clear, interview-style question for a human focused on "${area}" in the context of ${currentCoach} work.
Do NOT repeat or closely resemble any of the following last 10 questions:
${lastQuestions.map((q,i)=>`${i+1}. ${q}`).join('\n')}
Provide any constraints (input/output examples, limits), and include the expected key points and an objective rubric for grading. Then respond in JSON ONLY with keys:
  "question" (string),
  "questionTitle" (short title),
  "difficulty" ("easy"|"medium"|"hard"),
  "rubric" (string: short graded rubric describing what earns 100/75/50/25/0),
  "expectedPoints" (array of short bullet points of the key things to mention),
  "sampleAnswer" (a concise model answer),
  "hints" (array of brief hints),
  "timeSuggestion" (e.g., "5 minutes").
Keep JSON compact and valid. No extra commentary. All questions must be relevant to ${currentCoach} interviews.`;
  const user = `Generate one interview-style question for a ${currentCoach} in area: "${area}" with difficulty="${difficulty}". Make it practical and ask the user to explain reasoning, edge cases, and complexity when applicable. Output as JSON only.`;
  return { sys, user };
}

function buildGradePrompt(questionObj, userAnswer){
  const sys = `You are an expert interviewer and objective grader for ${currentCoach} interviews. The user has answered a ${currentCoach} interview question. Grade the response using the rubric provided. Return JSON ONLY with keys:
  - "grade": integer 0..100,
  - "feedback": string (give concise feedback and actionable improvements, and include a mnemonic to help remember the key concepts if applicable. If the answer is perfect, say "Perfect answer!"),
  - "breakdown": array of {criterion: string, weight: number, score: number, comment: string},
  - "correctness": boolean,
  - "confidence": number (0..1),
  - "improvedAnswer": string (a brief improved sample answer).
  Be honest and constructive. Do not include anything outside the JSON object. The mnemonic should be generated by you, not expected from the user.
  Do NOT repeat or quote the user's answer in the feedback.`;
  const user = `Question: ${questionObj.question}
Rubric: ${questionObj.rubric}
Expected points: ${Array.isArray(questionObj.expectedPoints)?questionObj.expectedPoints.join('; '):questionObj.expectedPoints}
Sample answer: ${questionObj.sampleAnswer}
User's answer:
${userAnswer}
Grade according to the rubric, assign numeric scores for each criterion, and produce the JSON response described. In the feedback, do NOT repeat or quote the user's answer; instead, provide concise, actionable feedback and a mnemonic if applicable. If the answer is perfect, say "Perfect answer!" All grading should be in the context of ${currentCoach} interviews.`;
  return { sys, user };
}

async function callOpenAI(messages, model, apiKey, max_tokens=800, temperature=0.2){
  const url = '/api/chat';
  const payload = {
    model: model || 'gpt-3.5-turbo',
    messages: messages,
    temperature: temperature,
    max_tokens: max_tokens
  };
  const resp = await csrfFetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });
  if(!resp.ok){
    const txt = await resp.text();
    throw new Error('OpenAI error: ' + resp.status + ' ' + txt);
  }
  const data = await resp.json();
  const content = data.choices?.[0]?.message?.content;
  if(!content) throw new Error('No content in response');
  return content;
}

function extractJSON(text){
  text = text.trim();
  try{ return JSON.parse(text); }catch(e){}
  const start = text.indexOf('{');
  const end = text.lastIndexOf('}');
  if(start>=0 && end>start){
    const sub = text.slice(start, end+1);
    try{ return JSON.parse(sub); }catch(e){}
  }
  const arrStart = text.indexOf('[');
  const arrEnd = text.lastIndexOf(']');
  if(arrStart>=0 && arrEnd>arrStart){
    const sub = text.slice(arrStart, arrEnd+1);
    try{ return JSON.parse(sub); }catch(e){}
  }
  return null;
}

function updateScores(area, grade, questionTitle, resultText){
  if(!scores[area]) scores[area] = {avg:0, attempts:0, last:undefined, history:[]};
  const a = scores[area];
  const total = (a.avg * a.attempts) + grade;
  a.attempts = (a.attempts || 0) + 1;
  a.avg = total / a.attempts;
  a.last = grade;
  a.history = a.history || [];
  a.history.push({time: nowISO(), questionTitle, grade, resultText});
  if ('streak' in a) delete a.streak;
  saveScores();
}

startBtn.addEventListener('click', async ()=>{
  const area = (areaSelect.value || '').trim();
  const diff = difficultySelect.value;
  if(!area){ alert('Please select an area to practice.'); areaSelect.focus(); return; }
  currentAreaLabel.textContent = `${area} — Question`;
  sidebarArea.textContent = area;
  questionBox.textContent = 'Generating question…';
  feedbackPane.style.display = 'none';
  hintPane.style.display = 'none';
  explanationPane.style.display = 'none';
  answerInput.value = '';
  startBtn.disabled = true;
  submitBtn.disabled = true;
  hintBtn.disabled = true;
  explainBtn.disabled = true;
  try{
    const {sys, user} = buildQuestionPrompt(area, diff);
    const messages = [
      {role:'system', content: sys},
      {role:'user', content: user}
    ];
    const raw = await callOpenAI(messages, undefined, undefined, 800, 0.3);
    let obj = extractJSON(raw);
    if(!obj){
      throw new Error('Could not parse question JSON from model. Raw response:\n'+raw);
    }
    obj.difficulty = obj.difficulty || diff;
    obj.questionTitle = obj.questionTitle || (obj.question || '').slice(0,80);
    currentQuestion = obj;
    questionBox.textContent = obj.question || '(empty question)';
    qmeta.textContent = `Rubric available. Time suggestion: ${obj.timeSuggestion || '—'}`;
    qDifficulty.textContent = `Difficulty: ${obj.difficulty || diff}`;
    startTimer();
    submitBtn.disabled = false;
    hintBtn.disabled = false;
    explainBtn.disabled = false;
    if (obj.question) addQuestionToHistory(obj.question);
  }catch(err){
    questionBox.textContent = 'Error generating question: ' + (err.message||err);
    console.error(err);
  } finally {
    startBtn.disabled = false;
  }
  renderSidebar(areaSelect.value);
});

submitBtn.addEventListener('click', async ()=>{
  if(!currentQuestion){ alert('No current question. Press Start Question first.'); return; }
  const userAnswer = answerInput.value.trim();
  if(!userAnswer || userAnswer.toLowerCase().startsWith('hint:')) {
    alert('Please enter your own answer before submitting.');
    return;
  }
  if (userAnswer === lastSubmittedAnswer) {
    alert('You have already submitted this answer. Please modify your answer before submitting again.');
    return;
  }
  lastSubmittedAnswer = userAnswer;
  submitBtn.disabled = true;
  startBtn.disabled = true;
  answerInput.disabled = true;
  hintBtn.disabled = true;
  explainBtn.disabled = true;
  stopTimer();
  const timeTaken = Math.floor((Date.now() - (questionStartTime||Date.now()))/1000);
  try{
    const {sys, user} = buildGradePrompt(currentQuestion, userAnswer);
    const messages = [
      {role:'system', content: sys},
      {role:'user', content: user}
    ];
    const raw = await callOpenAI(messages, undefined, undefined, 900, 0.0);
    let gradeObj = extractJSON(raw);
    if(!gradeObj){
      try{
        const fallbackMessages = [
          {role:'system', content: 'You will only output valid JSON and nothing else.'},
          {role:'user', content: 'The model returned an unparsable response. Please return only the JSON object again with the grading keys: grade, feedback, breakdown, correctness, confidence, improvedAnswer.'}
        ];
        const tryAgain = await callOpenAI(fallbackMessages, undefined, undefined, 300, 0.0);
        gradeObj = extractJSON(tryAgain);
      }catch(e){}
    }
    if(!gradeObj) throw new Error('Could not parse grader output. Raw output:\n' + raw);
    let gradeVal = Math.round(Number(gradeObj.grade));
    if(isNaN(gradeVal)) gradeVal = 0;
    if(gradeVal < 0) gradeVal = 0;
    if(gradeVal > 100) gradeVal = 100;
    feedbackPane.style.display = 'block';
    feedbackGrade.textContent = `${gradeVal}%`;
    feedbackBox.textContent = gradeObj.feedback || 'No feedback provided.';
    let improvedText = '';
    if (Array.isArray(gradeObj.breakdown) && gradeObj.breakdown.length > 0) {
      improvedText += 'Key Areas for Improvement:\n';
      improvedText += gradeObj.breakdown
        .filter(b => b.score < b.weight)
        .map(b => `- ${b.criterion}: ${b.comment}`)
        .join('\n');
      improvedText += '\n\n';
    }
    let mnemonicMatch = (gradeObj.feedback || '').match(/mnemonic.*?:\s*([^\n]+)/i);
    if (mnemonicMatch && mnemonicMatch[1]) {
      improvedText += `Mnemonic: ${mnemonicMatch[1]}`;
    }
    improvedAnswerBox.style.display = improvedText.trim() ? 'block' : 'none';
    improvedAnswerBox.textContent = improvedText.trim();

    const area = areaSelect.value || 'General';
    updateScores(area, gradeVal, currentQuestion.questionTitle || 'Question', `Grade ${gradeVal}%`);
    renderSidebar(area);
    statusMsg.textContent = `Last graded: ${gradeVal}% • ${timeTaken}s`;
  }catch(err){
    console.error(err);
    alert('Error grading answer: ' + (err.message||err));
  } finally {
    submitBtn.disabled = false;
    startBtn.disabled = false;
    answerInput.disabled = false;
    hintBtn.disabled = false;
    explainBtn.disabled = false;
  }
});

hintBtn.addEventListener('click', async ()=>{
  if(!currentQuestion){ alert('No question yet.'); return; }
  hintBtn.disabled = true;
  feedbackPane.style.display = 'none';
  explanationPane.style.display = 'none';
  hintPane.style.display = 'none';
  try{
    improvedAnswerBox.style.display = 'none';
    let hintText = '';
    if(Array.isArray(currentQuestion.hints) && currentQuestion.hints.length){
      const hint = currentQuestion.hints.shift(); 
      hintText = `Hint: ${hint}`;
    } else {
      const messages = [
        {role:'system', content:`You are a helpful interviewer assistant for ${currentCoach} interviews. Provide one concise hint for the user to answer the following question, without revealing the full solution.`},
        {role:'user', content: `Question:\n${currentQuestion.question}\nProvide a short hint (one or two sentences). Return only the hint.`}
      ];
      const raw = await callOpenAI(messages, undefined, undefined, 150, 0.5);
      hintText = `Hint: ${raw.trim()}`;
    }
    hintBox.textContent = hintText;
    hintPane.style.display = 'block';
  }catch(err){
    console.error(err);
    alert('Could not fetch hint: ' + (err.message||err));
  } finally {
    hintBtn.disabled = false;
  }
});

explainBtn.addEventListener('click', async ()=>{
  if(!currentQuestion){ alert('No question yet.'); return; }
  explainBtn.disabled = true;
  feedbackPane.style.display = 'none';
  hintPane.style.display = 'none';
  explanationPane.style.display = 'none';
  try{
    const messages = [
      {role:'system', content:`You are an expert interviewer for ${currentCoach} interviews who explains concise model answers and tradeoffs. Respond in plain text only. Do NOT use Markdown, bullet points, or special formatting. Avoid special characters.`},
      {role:'user', content:`Question:\n${currentQuestion.question}\nSample answer:\n${currentQuestion.sampleAnswer || ''}\nExplain only the main points, tradeoffs, and provide a mnemonic if applicable. Do not explain the purpose of the question or give background. Focus on helping the user learn how to answer this type of question well. Respond in plain text only, no Markdown or special formatting.`}
    ];
    const raw = await callOpenAI(messages, undefined, undefined, 400, 0.1);
    explanationBox.textContent = raw;
    explanationPane.style.display = 'block';
    feedbackGrade.textContent = '';
    improvedAnswerBox.style.display = 'none';
    statusMsg.textContent = 'Model explanation shown';
  }catch(err){
    console.error(err);
    alert('Could not fetch explanation: ' + (err.message||err));
  } finally {
    explainBtn.disabled = false;
  }
});

document.getElementById('resetAreaBtn').addEventListener('click', ()=>{
  const area = areaSelect.value || prompt('Area to reset (empty to cancel):');
  if(!area) return;
  if(confirm(`Reset stored scores for area "${area}"?`)){
    delete scores[area];
    saveScores();
    renderSidebar(area);
  }
});
document.getElementById('resetAllBtn').addEventListener('click', ()=>{
  if(confirm('Reset ALL stored scores? This clears local progress.')){
    scores = {};
    saveScores();
    clearQuestionHistory();
    renderSidebar('');
  }
});

function renderAreaScoresSummary() {
  const keys = Object.keys(scores).filter(k => scores[k] && scores[k].attempts > 0);
  if (keys.length === 0) {
    areaScoresSummary.innerHTML = '<div class="tiny muted" style="text-align:center;">No area scores yet.</div>';
    return;
  }
  areaScoresSummary.innerHTML = `
    <div class="small muted" style="margin-bottom:8px;text-align:center;">Your Area Scores</div>
    <div style="display:flex;flex-direction:column;gap:6px;">
      ${keys.map(area => {
        const a = scores[area];
        return `
          <div class="stat area-score-item" data-area="${encodeURIComponent(area)}" style="padding:8px 12px; position:relative; cursor:pointer; display:flex; align-items:center;">
            <button class="area-score-delete" title="Delete area score" style="background:none;border:none;color:#ff6b6b;font-size:1.2em;cursor:pointer;margin-right:10px;">✕</button>
            <div style="flex:1;">
              <span style="font-weight:700;color:var(--accent-2)">${area}</span>
              <span class="tiny muted" style="margin-left:6px;">Attempts: ${a.attempts}</span>
            </div>
            <div style="font-weight:700;color:var(--accent);font-size:1.1em">${Math.round(a.avg)}%</div>
          </div>
        `;
      }).join('')}
    </div>
  `;

  areaScoresSummary.querySelectorAll('.area-score-delete').forEach(btn => {
    btn.addEventListener('click', function(e) {
      e.stopPropagation();
      const parent = btn.closest('.area-score-item');
      const area = decodeURIComponent(parent.getAttribute('data-area'));
      if (confirm(`Delete score for area "${area}"?`)) {
        delete scores[area];
        saveScores();
        renderSidebar(areaSelect.value);
      }
    });
  });

  areaScoresSummary.querySelectorAll('.area-score-item').forEach(item => {
    item.addEventListener('contextmenu', function(e) {
      e.preventDefault();
      const area = decodeURIComponent(item.getAttribute('data-area'));
      if (confirm(`Delete score for area "${area}"?`)) {
        delete scores[area];
        saveScores();
        renderSidebar(areaSelect.value);
      }
    });
  });
}

function collapseAreaSelect() {
  areaSelect.classList.remove('scrollable');
  areaSelect.removeAttribute('size');
}

function expandAreaSelect() {
  const rows = areaSelect.dataset.scrollRows;
  if (rows) {
    areaSelect.classList.add('scrollable');
    areaSelect.setAttribute('size', rows);
  }
}

function configureAreaSelectScroll() {
  const optionCount = Math.max(0, areaSelect.options.length - 1);
  if (optionCount > 15) {
    areaSelect.dataset.scrollRows = String(Math.min(optionCount + 1, 15));
  } else {
    delete areaSelect.dataset.scrollRows;
    collapseAreaSelect();
  }
}

(function init(){
  const lastArea = localStorage.getItem('interviewTutorLastArea') || '';
  if(lastArea) { areaSelect.value = lastArea; sidebarArea.textContent = lastArea; currentAreaLabel.textContent = `${lastArea} — Ready`; }
  renderSidebar(areaSelect.value);
  configureAreaSelectScroll();
  areaSelect.addEventListener('change', ()=> {
    collapseAreaSelect();
    localStorage.setItem('interviewTutorLastArea', areaSelect.value);
    renderSidebar(areaSelect.value);
    currentAreaLabel.textContent = areaSelect.value ? `${areaSelect.value} — Press Start` : 'Pick an area and press Start';
  });
  areaSelect.addEventListener('focus', expandAreaSelect);
  areaSelect.addEventListener('click', expandAreaSelect);
  areaSelect.addEventListener('blur', collapseAreaSelect);
})();

coachSubmitBtn.addEventListener('click', async () => {
    const coach = coachInput.value.trim();
    if (!coach) {
      alert('Please enter a career coach type.');
      coachInput.focus();
      return;
    }
    coachSubmitBtn.disabled = true;
    areaSelect.disabled = true;
    areaSelect.innerHTML = '<option>Checking area safety…</option>';
    configureAreaSelectScroll();
    collapseAreaSelect();
    try {
      const safeResp = await csrfFetch('/api/check_area', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ area: coach })
      });
      const safeData = await safeResp.json();
      if (!safeData.safe) {
        areaSelect.innerHTML = '<option value="">Area not allowed</option>';
        areaSelect.disabled = true;
        startBtn.disabled = true;
        configureAreaSelectScroll();
        collapseAreaSelect();
        coachSubmitBtn.disabled = false;
        alert('This area is not allowed for coaching: ' + (safeData.reason || 'Unsafe area.'));
        return;
      }
      currentCoach = coach;
      localStorage.setItem('interviewTutorLastCoach', coach);
      updateHeaderCoach();
      areaSelect.innerHTML = '<option>Loading areas…</option>';
      try {
        const resp = await csrfFetch('/api/areas', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ coach })
        });
        if (!resp.ok) throw new Error('Failed to fetch areas');
        const data = await resp.json();
        const areas = data.areas || [];
        if (areas.length === 0) {
          areaSelect.innerHTML = '<option value="">No areas found</option>';
          areaSelect.disabled = true;
          startBtn.disabled = true;
          configureAreaSelectScroll();
          collapseAreaSelect();
        } else {
          areaSelect.innerHTML = '<option value="">Select area to practice</option>' +
            areas.map(a => `<option value="${a}">${a}</option>`).join('');
          areaSelect.disabled = false;
          startBtn.disabled = false;
          configureAreaSelectScroll();
          collapseAreaSelect();
        }
        localStorage.setItem('interviewTutorLastCoach', coach);
      } catch (err) {
        areaSelect.innerHTML = '<option value="">Error loading areas</option>';
        alert('Error fetching areas: ' + (err.message || err));
        areaSelect.disabled = true;
        startBtn.disabled = true;
        configureAreaSelectScroll();
        collapseAreaSelect();
      } finally {
        coachSubmitBtn.disabled = false;
      }
    } catch (err) {
      areaSelect.innerHTML = '<option value="">Error checking area safety</option>';
      alert('Error checking area safety: ' + (err.message || err));
      areaSelect.disabled = true;
      startBtn.disabled = true;
      configureAreaSelectScroll();
      collapseAreaSelect();
      coachSubmitBtn.disabled = false;
    }
  });
  (function initCoach() {
    const lastCoach = localStorage.getItem('interviewTutorLastCoach');
    if (lastCoach) {
      currentCoach = lastCoach;
      coachInput.value = lastCoach;
      updateHeaderCoach();
      if (!coachSubmitBtn.disabled) coachSubmitBtn.click();
    } else {
      updateHeaderCoach();
    }
  })();

  function updateHeaderCoach() {
    document.querySelector('h1').innerHTML = `Interview Tutor <span style="color:var(--muted);font-weight:600;">- ${currentCoach}</span>`;
    document.querySelector('p').textContent = `Practice, get graded, and level up your ${currentCoach} interview skills.`;
  }
</script>
</body>
</html>